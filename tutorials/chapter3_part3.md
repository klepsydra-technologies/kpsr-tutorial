<p align="right">
  <img width="25%" height="25%"src="../images/klepsydra_logo.jpg">
</p>

[Previous Tutorial: Performance Monitoring](./chapter3_part2.md)

# Chapter 3. Part III ROS connector

## Table of contents
* [Introduction](#introduction)
* [Folder structure](#folder-structure)
* [Generating headers for messages](#generating-headers-for-messages)
* [Klepsydra ROS API](#klepsydra-ros-api)
* [The main file](#the-main-file)
* [Working without Klepsydra message types](#working-without-klepsydra-message-types)
* [Building and running](#building-and-running)

<a name="introduction"></a>
## Introduction
In this case, we treat the case where sensor messages are being
broadcast using ROS and the middleware used is ROS. However, as we
know that klepsydra's event loop is faster, we use it, without any
changes to the service classes, to control the cubesat. In this case,
the overall code in the main file still retains the same structure as
the other examples. We list below what steps differ and what different
API we need to call.

<a name="folder-structure"></a>
## Folder structure

Since ROS uses catkin_make for compiling its nodes, we must adapt the
folder structure to it. The example for ROS is thus not in the
`examples` folder but however is in the [`tests/kpsr_ros_tests`](../tests/kpsr_ros_tests) folder
with the main file in the `src` subfolder. Create a new project in
your catkin workspace by using symlinks to the `tests/kpsr_ros_tests`
folder.

Given ```$KLEPSYDRA_HOME```, for example ```$HOME/klepsydra```, and
```$CATKIN_WORKSPACE```, for example ```$HOME/catkin_ws```:

```bash
mkdir -p $CATKIN_WORKSPACE/src
cd $CATKIN_WORKSPACE
source install/setup.bash
ln -s $KLEPSYDRA_HOME/kpsr-tutorial/tests/kpsr_ros_tests
```

The YAML files for messages should include additional fields that
specify ROS as the middleware. These files are stored in the kidl
folder. Note the difference compared to the YAML files used for
examples 1, 2 or 3.

<a name="generating-headers-for-messages"></a>
## Generating headers for messages

*Note see section below for working without generating Klepsydra messages*

In the previous cases, the header files generated by `kpsr-codegen`
for example 1 were sufficient for use in examples 1, 2 and 3. However,
when generating for use with ROS middleware, we must regenerate them
from the newer YAML files in the [`tests/kpsr_ros_tests/kidl`}((../tests/kpsr_ros_tests/kidl)
folder. As mentioned previously, they contain additional fields
specific to the ROS middleware, and the code generation command should
be called specifying ROS should not be disabled.

The CMakeLists file takes care of this by running the following command:
```
kpsr_codegen -i kidl -o gen klepsydra/tutorial -r False -z True -d True
```

The generated files are then stored inside the `gen` folder. The pure
C++ objects are stored in the `poco/include` folder while ROS specific
mapper classes are stored in the `rostg/include` folder. The mapper
classes allow the code to transform ROS objects/classes to pure C++
objects.

<a name="klepsydra-ros-api"></a>
## Klepsydra ROS API

Let's start with the sample code of example 3. For using with ros, we
should use API from the klepsydra ros core (`kpsr_ros_core`). The
event loop provider is kept the same as it provides a high performance
loop that is faster than ros. The environment is defined using the
`RosEnv` class (that takes in the nodehandle as a parameter).

The `fromRosProvider` allows us to register a Klepsydra subscriber
that *reads messages from the ROS publisher* that is publishing the
battery values.

Similarly, the `toRosProvider` allows us to declare a klepsydra
publisher that publishes the status event data which can then be
accessed from ROS using a ROS subscriber.

We pass these subscribers and publishers (using the event loop
middleware provider, as in the 3rd example previously) to the control
service class and the application service class.

<a name="the-main-file"></a>
## The main file

Finally, just as in the case of the previous examples, we write the
rest of the code to simulate the sensor data. The [`example_ros.cpp`](../tests/kpsr_ros_tests/src/example_ros.cpp)
provides the complete code.

<a name="working-without-klepsydra-message-types"></a>
## Working without Klepsydra message types

In some cases it may be preferable to work with your own custom ROS
message types and not have to deal with creating YAML files for each
custom message type. In such a case, Klepsydra can be used directly
with your ROS messages.

For this case, we have to do very few modifications to the main file
and the new code is provided in [`example_ros_identity.cpp`](../tests/kpsr_ros_tests/src/example_ros_identity.cpp). In this
case, we will have to rewrite our ControlService class as it
heavily depends on the type of messages we have used. The new
re-written class is provided in [`control_service_ros.h`](../tests/kpsr_ros_tests/include/control_service_ros.h)/[`.cpp`](../tests/kpsr_ros_tests/src/control_service_ros.cpp). Notice
that as compared to the previous classes and code, the difference is
only in the syntax as opposed to program logic.

<a name="building-and-running"></a>
## Building and running

Unlike other examples of klepsydra, we must use catkin for building
the code. If your catkin workspace path is given by $CATKIN_WORKSPACE,
then use the following commands:

```
cd $CATKIN_WORKSPACE
source ./install/setup.bash  # (If this is not already done before)
catkin_make kpsr_ros_tutorial_example
```

The executable will be generated in the `devel/lib/` folder and can be
run directly. (Note, the example expects a valid ROS master running on
the network. You can easily start it by typing `roscore` in a new
shell.)

[Next Tutorial: DDS connector](./chapter3_part4.md)

