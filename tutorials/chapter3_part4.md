<p align="right">
  <img width="25%" height="25%"src="../images/klepsydra_logo.jpg">
</p>

[Previous Tutorial: ROS connector](./chapter3_part3.md)

# Chapter 3. Part IV DDS connector

## Table of contents
* [Introduction](#introduction)
* [Generating headers for messages](#generating-headers-for-messages)
* [Klepsydra DDS API](#klepsydra-dds-api)
* [The main file](#the-main-file)

<a name="introduction"></a>
## Introduction
In this case, we treat the case where sensor messages are being
broadcast using DDS and the middleware used is DDS. However, as we
know that klepsydra's event loop is faster, we use it, without any
changes to the service classes, to control the cubesat. In this case,
the overall code in the main file still retains the same structure as
the other examples. We list below what steps differ and what different
API we need to call.

Unlike ROS, DDS does not need catkin, so it can be built normally with
cmake and make.

<a name="generating-headers-for-messages"></a>
## Generating headers for messages

Similar to ROS, we need to generate message header files that will be
used by the code. The existing YAML files contain fields related to
DDS middleware which are only used by the code-generator if specify
that DDS should not be disabled. The default CMakeLists handles this
by checking if the variable `KPSR_WITH_DDS` is set to true. Thus, the
example must first be configured by running :

```
cd build
cmake -DKPSR_WITH_DDS=true ..
```

The CMakeLists is configured to then run the following command:
```
kpsr_codegen -i kidl -o gen klepsydra/tutorial -r True -z True -d False
```

The generated files are then stored inside the gen folder. The pure
C++ objects are stored in the `poco/include` folder while DDS specific
mapper classes are stored in the `dds/include/klepsydra/tutorial/dds`
folder. The mapper classes allow the code to transform DDS
objects/classes to pure C++ objects. Additionally, DDS specific
headers are also generated and stored in the `dds/gen` folder.

<a name="klepsydra-dds-api"></a>
## Klepsydra DDS API

Similar to the ROS example, and example 3, we use the high performance
event loop provider. The environment is defined for this example using
the basic memory environment ([`MemEnv`](https://github.com/klepsydra-technologies/kpsr-core/blob/main/core/modules/mem_mdlw/include/klepsydra/mem_core/mem_env.h)).

For registering subscribers, we use the [`FromDDSMiddlewareProvider`](https://github.com/klepsydra-technologies/kpsr-core/blob/main/core/modules/dds_mdlw/include/klepsydra/dds_core/from_dds_middleware_provider.h) class. This
allows us to register a subscriber to read battery values and/or
temperature values.

The [`ToDDSMiddlewareProvider`](https://github.com/klepsydra-technologies/kpsr-core/blob/main/core/modules/dds_mdlw/include/klepsydra/dds_core/to_dds_middleware_provider.h) class allows us to declare a klepsydra publisher that
publishes the status event data which can then be accessed from DDS.

Using the event loop middleware provider, the subscribers and
publishers are then passed to the control service class and the
application service class.

<a name="the-main-file"></a>
## The main file

Finally, just as in the case of previous example, we write the
rest of the code to simulate the sensor data. The [`example_dds.cpp`](../examples/dds_mdlw/src/example_dds.cpp)
provides the complete code.


Note that in case of DDS, we need to define DDS Topic,
DomainParticipant, Subscriber and Publisher as generally required by
DDS applications. However, the difference is that we templatize them
using the class types that are generated by us in the [header
generation step](#Generating_headers_for_messages).

